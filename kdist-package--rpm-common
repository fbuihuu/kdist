#! /bin/bash

declare -a rpm_sources
rpm_log=false
rpm_annotate_spec=false

rpm_specfile=
package_with_devel=0
package_with_debuginfo=0

__resolve_one_spec () {
	local build_srpm=0
	local tmpfile1=$(mktemp)
	local tmpfile2=$(mktemp)
	local rpm_exclusive=$(echo $(rpm__architecture $rpm_exclusive))

	[ $package_format == srpm ] && build_srpm=1

	if test -z "$package_description"; then
		package_description="This %{name} is for testing purpose only"
	fi
	echo "$package_description" >$tmpfile1

	for i in ${!rpm_sources[*]}; do
		echo "Source$i:		${rpm_sources[i]}"
	done >$tmpfile2

	sed -e "/@RPM_DESCRIPTION@/r $tmpfile1" -e "/@RPM_DESCRIPTION@/d" \
		-e "/@RPM_SOURCES@/r $tmpfile2" -e "/@RPM_SOURCES@/d" \
		-e "s,@RPM_NAME@,$package_name," \
		-e "s,@RPM_VERSION@,${package_version//-/.}," \
		-e "s,@SRC_UNAME_R@,$src_uname_r," \
		-e "s,@UNAME_R@,$uname_r," \
		-e "s,@SOURCE_RELEASE@,${source_release//-/.}," \
		-e "s,@BUILD_RELEASE@,$build_release," \
		-e "s,@FLAVOUR@,${package_name#kernel-}," \
		-e "s,@RPM_EXCLUSIVE@,$rpm_exclusive," \
		-e "s,@ARCHIVE@,$package_archive," \
		-e "s,@NO_SOURCE@,$no_source," \
		-e "s,@BUILD_SRPM@,$build_srpm," \
		-e "s,@BUILD_DEVEL@,$package_with_devel," \
		-e "s,@BUILD_DEBUG@,$package_with_debuginfo," $1

	rm -f $tmpfile1 $tmpfile2
}

__show_one_line () {
	local line=$1
	if $rpm_annotate_spec
	then
		line=$(echo "$line" | expand)
		printf "%-26s %s\n" "${2:-${FUNCNAME[1]}()}" "$line"
	else
		echo "$line"
	fi
}

__show_one_file () {
	case $1 in
	*.spec.in)	__resolve_one_spec $1 ;;
	*)		cat $1
	esac |
	# be sure to print the last line even if there's no EOL at end
	# of file.
	while read -r || [ -n "$REPLY" ]
	do
		__show_one_line "$REPLY" "$1"
	done
}

__show_one_subsection () {
	local specfile="[[:digit:]][[:digit:]]-$1.spec?(.in)"
	local header=$2
	local footer=$3
	local tmpdir=$(mktemp -d)
	local merge

	shopt -s nullglob extglob
	for arch in $rpm_exclusive; do
		for path in $(kdist__architecture $arch)/$specfile; do
			i=$(basename ${path%%-*})
			merge=false
			if test -f $tmpdir/$i; then
				# try to merge with a previous registered arch
				while read old_path unused; do
					cmp -s $old_path $path && {
						merge=true
						break
					}
				done <$tmpdir/$i
			fi
			if $merge; then
				sed -i -e "s|^${old_path}.*|& ${arch}|" $tmpdir/$i
			else
				echo "$path $arch" >>$tmpdir/$i
			fi
		done
	done
	for path in $specfile; do
		i=${path%%-*}
		test -f $i && die "rpm: multiple definition for $path"
		echo $path >$tmpdir/$i
	done
	shopt -u nullglob extglob

	if test -n "$(ls $tmpdir)"; then
		[ -n "$header" ] && __show_one_line "$header"
		for f in $(ls -1v $tmpdir/*)
		do
			while read file archs; do
				# remove embedded newlines.
				archs=$(echo $(rpm__architecture $archs))
				[ -n "$archs" ] && __show_one_line "%ifarch $archs"
				__show_one_file $file
				[ -n "$archs" ] && __show_one_line "%endif"
			done <$f
			__show_one_line ""
		done
		[ -n "$footer" ] && __show_one_line "$footer"
		__show_one_line ""
	fi
	rm -fr $tmpdir
}

__show_one_section () {
	__show_one_subsection $1 "" ""
	__show_one_subsection $1-devel "%if %build_devel" "%endif"
	__show_one_subsection $1-debug "%if %build_debug" "%endif"
}

__show_spec () {
	pushd ${1:-binaries} >/dev/null
	[ -f macros.spec.in ] && {
		__show_one_file macros.spec.in
	}
	#
	# If 'rpm_exclusive' is not set (ie for all targets except the
	# binary one) then we include all supported architectures.
	#
	if test -z "$rpm_exclusive"; then
		# assume no space in the dir name
		rpm_exclusive=($echo */)
		rpm_exclusive=${rpm_exclusive[*]%/}
	fi
	__show_one_section header
	__show_one_section package
	__show_one_section description
	__show_one_section prep
	__show_one_section build
	__show_one_section install
	__show_one_section clean
	__show_one_section post
	__show_one_section postun
	__show_one_section preun
	__show_one_section files
	popd >/dev/null
}

show_spec_changelog () {
	package__show_changelog | while read
	do
		__show_one_line "$REPLY"
	done
}

show_spec () {
	if test "$rpm_specfile"; then
		__show_one_file "$rpm_specfile"
		return
	fi

	pushd $(kdist__get_repository packaging/rpm) >/dev/null

	__show_one_line "#"
	__show_one_line "# Spec file generated by kdist version $(kdist_version)"
	__show_one_line "#"
	__show_one_file macros.spec.in
	__show_one_line ""
	__show_spec $1

	popd >/dev/null

	# it needs to be called inside the kernel git repository.
	show_spec_changelog
}

rpm__architecture () {
	local arg arch

	for arg; do
		echo $arg
	done | sort | uniq | while read arch
	do
		case $arch in
		x86_64)		echo x86_64 ;;
		i?86|x86_32)	echo %ix86 ;;
		arm*)		echo %arm ;;
		*)		die "Unsupported architecture '$arch'"
		esac
	done
}

# rpm_output_directory is always an absolute path in canonicalize
# form so we can use it in any contexts.
rpm_output_directory=$(pwd)
# rpm_output_directory_user is the path set by the user with a single
# trailing slash.
rpm_output_directory_user=

rpm__set_output_directory () {
	rpm_output_directory=$(readlink -e "$1") &&
	shopt -s extglob &&
	rpm_output_directory_user=${1%%*(/)}/ &&
	shopt -u extglob ||
	warn "Invalid output directory '$1'."
}

rpm_tmpdir=
rpm__mktemp () {
	# Avoid cross dev copies
	if ! test $rpm_tmpdir; then
		rpm_tmpdir=$(mktemp -d --tmpdir=$rpm_output_directory)
		mkdir -p $rpm_tmpdir/{SOURCES,SPECS}
		SPECS=$rpm_tmpdir/SPECS
		SOURCES=$rpm_tmpdir/SOURCES
	fi
}

rpm__rpmbuild () {
	(
		[ "$verbose" != yes ] &&
			exec >/dev/null 2>/dev/null
		rpmbuild --define "_topdir $rpm_tmpdir" "$@"
	) &&

	for f in $(find $rpm_tmpdir/{SRPMS,RPMS} -type f); do
		mv $f $rpm_output_directory
		echo ${rpm_output_directory_user}$(basename $f)
	done
}

rpm__init () {
	if [ -n "$rpm_specfile" ]; then
		[ -r "$rpm_specfile" ] ||
			die "failed to read '$rpm_specfile'"
		# make the path absolute since we're going to move to the
		# kernel topdir.
		rpm_specfile=$(readlink -f "$rpm_specfile")
	fi

	# Create a tmpdir needed by all rpm packaging helpers.
	cleanup_on_exit () {
		rm -fr $rpm_tmpdir
	}
	trap cleanup_on_exit 0
	rpm__mktemp
}
