#! /bin/bash
#
# debuginfo can only be generated by rpm if it's used in its favourite
# environment (BUILD/, BUILDROOT/, etc...). Therefore --with-debuginfo
# is only available when generating source rpm package.
#
USAGE="[--format=rpm] [-v] [-j<n>] [--with-devel] [--show-spec|--annotate-spec] [--spec=<specfile>] [--output-dir|-o <dir>] [source|headers|firmware|tools/<name>]

   source            Package the kernel sources
   headers           Package the kernel header files
   firmware          Package the firmware
   tools/<name>      Package a named kernel tool

   --output-dir      Use <dir> to store the resulting files
   --show-spec       Show the generated spec file and exit
   --annontate-spec  Show the generated spec file with annotations and exit
   --spec            Specify the .spec file to use

   --with-devel      Build also the kernel devel package

   -j<n>             Used by make
"

source $libexecdir/kdist-package--rpm-common

package_source () {
	say "Extracting kernel $src_uname_r source code"
	kdist package --format=tar -q --prefix=$package_archive/ -j \
		-o $SOURCES/$package_archive.tar.bz2 source &&
	show_spec source >$SPECS/$package_name.spec &&
	rpm__rpmbuild -bb $SPECS/$package_name.spec
}

package_other () {
	if test $spec_only; then
		show_spec $1
		return
	fi
	if test $1 = source; then
		package_source
		return
	fi
	show_spec $1 >$SPECS/$package_name.spec &&
	rpm__rpmbuild --define "_builddir $(pwd)" -bb $SPECS/$package_name.spec
}

#
# We can't have a build release number included in the kernel release
# name (uname -r) since we would have to recompile the kernel and we
# want to avoid that since we don't know how the user did
# it. Therefore the build release number is only part of the package
# name.
#
package_flavour () {
	rpm_exclusive=$(config__read_architecture $1)

	uname_r=$(make -s ARCH=$rpm_exclusive kernelrelease)

	if test $spec_only; then
		show_spec
		return
	fi

	case $rpm_exclusive in
	x86_64)		asmarch=x86 ;;
	i386)		asmarch=x86 ;;
	arm*)		asmarch=arm ;;
	esac

	test $package_with_devel &&
	say "Generating devel-file list for '$asmarch' architecture" &&
	package__list_devel_files >$SOURCES/${uname_r}-develfiles.list &&
	package__list_output_devel_files >$SOURCES/${uname_r}-output-develfiles.list &&
	package__list_arch_devel_files $asmarch >$SOURCES/${uname_r}-$asmarch-develfiles.list ||
	return

	#
	# Generate the ugliness and call the only tool that can parse
	# it. We still take care of a potential file with the same
	# name.
	#
	show_spec >$SPECS/$package_name.spec &&
	rpmbuild --nobuild $SPECS/$package_name.spec &&
	rpm__rpmbuild --define "_builddir $(pwd)" -bb $SPECS/$package_name.spec
}

#
# Main
#
no_source=0
spec_only=

while
	case $1 in
	-v|--verbose)
		verbose=yes ;;
	--show-spec)
		spec_only=yes ;;
	--annotate-spec)
		spec_only=yes
		rpm_annotate_spec=true ;;
	--spec=*)
		rpm_specfile=${1#*=} ;;
	-o)
		shift
		rpm__set_output_directory "$1" || exit ;;
	--output-dir=*)
		rpm__set_output_directory "${1#*=}" || exit ;;
	--with-devel)
		package_with_devel=yes ;;
	-*)
		usage ;;
	*)
		break
	esac
do
	shift
done

if test $# -gt 1; then
	usage
fi

case $1 in
firmware|headers|source|tools/*)
	;;
'')
	#
	# FIXME: it would be nice to check that the kernel has been
	# compiled and vmlinux is uptodate.
	#
	local_build_release=yes ;;
*)
	usage
esac

rpm__init &&
package__main $1
