#! /bin/bash

USAGE="propagate [-i] [-n|--dry-run] [--no-verify] [--type=<type>] [--origin=<pattern>] [<pattern>...]"

stage_opts=
resolve_opts=
verify=yes
origin=
dry_run=

while
	case $1 in
	-i)		stage_opts="-i -p" ;;
	--origin=*)	origin=${1#--origin=} ;;
	--no-verify)	verify= ;;
	--type=*)	resolve_opts="--type=${1#--type=}" ;;
	-n|--dry-run)	dry_run=yes ;;
	-*)		usage ;;
	*)		break
	esac
do
	shift
done


#
# Depending on where we exit, later we'll need to restore the index's
# previous state if we detect an error.
#
cleanup_on_exit () {
	rm -fr $tmpdir
}

cleanup_on_error () {
	cd $(kdist__get_repository configs)
	git reset -q --hard HEAD &&
	if test $stash_id; then
		if ! git stash apply -q --index $stash_id; then
			warn "Error when restoring back the previous state !"
			warn "Your previous changes are still stashed."
			warn "Please restore then manually with git-stash."
		fi
	fi
	cleanup_on_exit
}

trap cleanup_on_exit 0

stash_id=
tmpdir=$(mktemp -d)

#
# Sanity checks on the current config
#
kdist__cd_kernel_topdir &&
kernel_path=$(pwd) ||
exit

if ! test -f .config; then
	die ".config is missing, aborting."
fi

patch=$tmpdir/diff
kdist config diff --raw $origin >$patch || {
	if test -z "$origin"; then
		warn "Can't generate the patch to propagate, probably because"
		warn "the origin file can't be found. You can try to pass '--origin'."
	fi
	exit 1
}

if ! test -s $patch; then
	die "No local changes to propagate"
fi

#
# Sanity checks on the targets
#
if test $# -eq 0; then
	#
	# No target is specified, use the defaut one based on the
	# current configuration. We'll also verify the config with the
	# current kernel.
	#
	name=$(config__read_flavour .config) &&
	test -n "$name" ||
	die "Missing CONFIG_NAME, don't know where to propagate changes."

	arch=$(config__read_architecture .config) &&
	test -n "$arch" ||
	die "Unable to determine the architecture of the current config."

	set $arch/$name
fi

targets=$(config__resolve_files $resolve_opts "$@") || exit
if ! test "$targets"; then
	die "No config files match '${@:-<empty>}' pattern."
fi

#
# Refuse to process if any files have changes which have not been
# staged since it's currently not possible for git-stash to leave them
# intact (therefore they won't be restored in case of no errors since
# git-apply won't be called).
#
kdist__cd_repository configs

for t in $targets; do
	case $(git status --porcelain -- $t) in
	" "[MD]" "*)
		die "$t has unstaged changes, exiting." ;;
	"?? "*)
		die "$t is currently not tracked." ;;
	esac
done

#
# Now we're going to play with the index, so back it up.
#
if ! git__check_clean_work_tree 2>/dev/null; then
	stash_id=$(git stash create) ||
	die "git-stash failed"
fi
trap cleanup_on_error 0

#
# convert a config revision into a kernel tag
#
verify_config () {
	local config=$(readlink -f $1)
	local conf_rev=${1%%/*}
	local kern_rev

	if ! test $verify; then
		return
	fi

	pushd $kernel_path >/dev/null

	kern_rev=$(config__map_to_kernel $conf_rev) &&
	echo "Updating $1 with $kern_rev kernel..." ||
	exit

	#
	# Just reuse the devel source if it already exists
	#
	if ! test -d $tmpdir/kernel-devel-$kern_rev; then
		kdist package --format=tar --prefix=kernel-devel-$kern_rev \
			-r $kern_rev devel | tar -C $tmpdir -xf - ||
		die "Failed to get the devel package for rev $rev"
	fi
	cd $tmpdir/kernel-devel-$kern_rev

	#
	# Run Kbuild to update the config file.
	#
	arch=$(config__read_architecture $config)

	KCONFIG_OVERWRITECONFIG=1 KCONFIG_CONFIG=$config \
		make -s ARCH=$arch oldconfig ||
		die "Failed to run make oldconfig for $t"

	popd >/dev/null
}


for t in $targets
do
	echo "Patching $t..."
	kdist config apply $t <$patch ||
	die "Failed to patch $t."

	verify_config $t ||
	die "Failed to update $t."

	echo "Staging changes in $t"
	git stage $stage_opts $t &&
	git checkout -- $t  ||
	die "Failed to propagate changes to $t."
done


if ! test $dry_run; then
	trap cleanup_on_exit 0
fi
