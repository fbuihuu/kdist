#! /bin/bash
#
# This helper is used to update a kernel configuration with minimum
# user interventions. It uses values found in a template when a symbol
# needs to be resolved. If the value cannot be determined then it asks
# for to the user.
#
# For example, after upgrading the desktop config for x86_64
# architecture, you can use this script to update the i586 desktop
# since a lot of new configurations will be the same. You'll be
# prompted for i586 specific symbol values only.
#
USAGE="upgrade [--template=<file>] <type> [<from>]"

declare -a targets
template=.config

while
	case $1 in
	--template=*)	template=$(readlink -f ${1#--template=}) ;;
	-*)		usage ;;
	*)		break
	esac
do
	shift
done

case $# in
1|2)	;;
*)	usage
esac

type=$1

kdist__cd_kernel_topdir &&
kdist__setup_kernel_version ||
exit

if ! test -f "$template"; then
	die "Template not found: $template"
fi

#
#
#
cleanup_on_exit () {
	rm -rf $tmpdir
}
trap "cleanup_on_exit" 0

tmpdir=$(mktemp -d)

#
# Retrieve the config files to be upgraded.
#
kdist__cd_repository configs

to=$(kdist__config_version $KERNEL_VERSION_BASE)
case $# in
1)
	# pickup the previous config version
	from=$({ echo $to; ls -1; } | sort -V | uniq | grep -B1 $to)
	case $(echo "$from" | wc -l) in
	2)	from=$(echo "$from" | head -1) ;;
	*)	die "No previous version found to upgrade from."
	esac
	echo "Upgrading from 'v$from'" ;;
2)
	from=$(kdist__config_version $2)
	test -d $from ||
	die "Unknown version '$2'."
esac

for src in $(config__ls_files --type=$type "$from/*/*")
do
	dst=${src/#$from/$to}

	test -f $dst &&
	die "That would overwrite the following file: '$dst'."

	mkdir -p $(dirname $tmpdir/$dst)
	cp $src $tmpdir/$dst
	targets+=("$dst")
done

test ${#targets[*]} -gt 0 ||
die "No config files with '$type' type found for version '$from'."

# go back to the kernel directory
cd - >/dev/null

#
# Ok this one is pretty crap...
#
read_conf_output () {
	while :
	do
		IFS='\' read -n1 -t0.005 -u${COPROC[0]} c 2>/dev/null
		rv=$?
		if ! test $rv -eq 0; then
			[ $rv -gt 128 ] && rv=0
			break
		fi

		case "$c" in
		'')	c="\n"
		esac
		CONF_REPLY+="$c"
	done
	return $rv
}

warn_about_wrong_guess () {
	warn "***"
	warn "*** I tried '$2' for '$1', but it seems invalid for this config."
	warn "***"
	warn "*** Please resolve this symbol manually."
	warn "***"
}


declare -i stats_resolv_auto=0
declare -i stats_resolv_user=0
declare -i stats_symbol_count=0

for config in "${targets[@]}"
do
	warn "Updating $config..."
	config=$tmpdir/$config

	coproc {
		export KCONFIG_CONFIG="$config"
		export KCONFIG_NOTIMESTAMP=1
		export KCONFIG_OVERWRITECONFIG=1

		make -s ARCH=$(config__read_architecture "$config") oldconfig
	}
	coproc_pid=$!

	while read_conf_output
	do
		case "$CONF_REPLY" in
		*choice\[*\]:" ")
			#
			# We have to resolve choices manually since we
			# don't know which symbol this choice
			# corresponds to.
			#
			echo -ne "$CONF_REPLY"
			read val
			echo >&${COPROC[1]} "$val"
			CONF_REPLY=""
			stats_resolv_user+=1
			;;
		*\[*\]" "\(NEW\)" ")
			#
			# Can the symbol's value be found in the
			# template ?
			#
			last_sym="$sym"
			sym=$(expr "$CONF_REPLY" : ".*(\([[:alnum:]_]*\)) \[") ||
			bug "unable to parse symbol"

			val=$(config__lookup_symbol_quotes $sym "$template") &&
			case $val in
			"")
				# symbol is not set
				val=N ;&
			\"*\")
				# strip the quotes
				val=${val#\"}
				val=${val%\"} ;&
			*)
				#
				# Try to detect if something's going wrong:
				# conf can reject our last guess. This is
				# probably something happening when different
				# architectures have different value ranges
				# for some symbols.
				#
				if test "$sym" = "$last_sym"; then
					#
					# Warn the user only once
					#
					[ -z "$notified" ] && {
						warn_about_wrong_guess $sym $val
						notified=yes
					}
					echo -ne "$CONF_REPLY"
					read val
					stats_resolv_user+=1
					stats_resolv_auto+=-1
				else
					#
					# Try to submit the value taken
					# from the template
					#
					notified=
					echo -ne "$CONF_REPLY"
					echo "$val"
					stats_resolv_auto+=1
				fi ;;
			esac || {
				# value is not in the template, ask to
				# the user to resolve this.
				echo -ne "$CONF_REPLY"
				read val
				stats_resolv_user+=1
			}
			echo >&${COPROC[1]} "$val"
			CONF_REPLY=""
			;;
		esac
	done

	if ! wait $coproc_id; then
		die "coproc exited abnormally ($?), aborting."
	fi

	stats_symbol_count+=$(grep -c ^CONFIG_ $config)
done

echo "=========================="
echo "Symbols resolved by kdist : $stats_resolv_auto"
echo "Symbols resolved by user  : $stats_resolv_user"
echo "Symbols total number      : $stats_symbol_count"
echo "=========================="

#
# Finally move the new confiles in the config repository.
#
kdist__cd_repository configs
rsync -a $tmpdir/ . &&
for config in "${targets[@]}"; do
	git add $config
done
