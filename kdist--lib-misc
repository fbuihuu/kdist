#! /bin/bash

#
# This can be used either for project or kernel releases. In the
# kernel case, the parent of v3.4.4-1 is v3.4.4, that is the function
# returns a release that was not done by kdist.
#
release__describe () {
	git describe --match=v[[:digit:]].[[:digit:]]\* "$@"
}

release__get_parent () {
	release__describe --abbrev=0 ${1:-HEAD}~1
}

module__list () {
	git submodule foreach -q 'echo $name'
}

# Given a release, return a module sha1 used to create that release.
module__get_sha1 () {
	local line=$(git ls-tree $1 -- $2) &&
	read mode type sha1 unused <<<$line &&
	echo $sha1
}

module__get_desc () (
	sha1=$(module__get_sha1 $1 $2) &&
	kdist__cd_repository $2 &&
	git describe --always --match "v[0-9]*" --abbrev=4 $sha1
)

#
# Returns in lower case the name of the Linux OS distribution name. It
# assumes that /etc/os-release is present.
#
# Now, lsb-release has been obsoleted by os-release (specified
# by the freedesktop standard).
#
runtime__distribution () {
	if test -f /etc/os-release; then
		(source /etc/os-release && echo ${ID,,})
		return
	fi
	warn "/etc/os-release is missing."
}

#
# Helpers for pattern matchings. A list of patterns can be provided
# and used later to check if a string matches any patterns already
# registered. If the pattern is a fixed string and results in a match,
# then this pattern is removed from the list.
#
declare -a __pattern_list

pattern__add () {
	__pattern_list+=("$@")
}

# Process first fixed string patterns so they can be removed from the
# list even if a pattern matches too.
pattern__has_match () {
	local string=$1 i p

	# fixed match ?
	for i in ${!__pattern_list[*]}; do
		p=${__pattern_list[i]}
		if test "$string" = "$p"; then
			echo "@@@@@ removing pattern '$p'"
			unset "__pattern_list[$i]"
			return 0
		fi
	done

	# pattern match ?
	for p in "${__pattern_list[@]}"; do
		if [[ "$string" = $p ]]; then
			return 0
		fi
	done
	return 1
}

pattern__is_empty () {
	test ${#__pattern_list[*]} -eq 0
}
