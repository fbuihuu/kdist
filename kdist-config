#! /bin/bash



USAGE="<command> [<args>]

The 'config' commands are:

   apply        Apply a diff to one config
   diff         Show diff between two configs
   import       Record the current config to the kdist config db
   info         Give information about a kernel configuration
   install      Set up a config for the tracked kernel
   list         List available configs matching the given pattern
   propagate    Propagate a change to specified configs
   update       Update configurations using a given kernel
   upgrade      Use a template to upgrade a set of configurations

See 'kdist config <command> --help' for more information on a specific command."

readonly kdist_subcommand=$1
shift

#
# Some internal config helpers.
#
__config__ls_files () {
	local arch pattern

	for arg in "$@"; do
		case $arg in
		*/*/*)
			vers=$(kdist__config_version "${arg%%/*}")
			arch="${arg%/*}"
			arch=$(kdist__architecture "${arch#*/}")
			pattern="$vers/$arch/${arg##*/}" ;;
		*/*)
			arch=$(kdist__architecture "${arg%/*}")
			pattern="$arch/${arg##*/}" ;;
		*)
			pattern="$arg"
		esac
		git ls-files "$pattern"
	done
}

config__ls_files () {
	local type fullpath filter=yes

	while
		case "$1" in
		--type=*)	type=${1#--type=} ;;
		--fullpath)	fullpath=yes ;;
		--no-filter)	filter= ;;
		*)		break
		esac
	do
		shift
	done

	dir=$(kdist__get_repository configs) && (
		cd "$dir"
		__config__ls_files "$@" | while read f
		do
			# 'import' command calls this function therefore the
			# information may not be present.
			if [ $type ]; then
				config_info__load $(basename $f)
				case $(config_info__get_type) in
				${type:-*})		;;
				*)	continue
				esac
			fi
			if [ $filter ]; then
				config_info__load $(basename $f)
				case $f in
				$(config_info__get_filter))	;;
				*)	continue
				esac
			fi

			echo "${fullpath:+$dir/}$f"
		done
	)
}

#
# Resolve try to guess some parts of the config pattern which can be
# missing. Therefore the result can be sometimes unexpected since it
# doesn't behave like a filename pattern.
#
# For examples:
#
#       *  ->  <vers>/<arch>/*
#     */*  ->  <vers>/*/*
#   */*/*  ->  */*/*
#
# Futhermore specifying explicitly an empty arch asks for replacing it
# with the current arch.
#
#    *//*  ->  */<arch>/*
#
config__resolve_files () {
	local pattern
	local -a opts

	while
		case $1 in
		-*)	opts+=("$1") ;;
		*)	break
		esac
	do
		shift
	done

	for pattern in "$@"; do
		# see above for some explanations.
		case $pattern in
		*//*)	pattern="${pattern%%/*}/$(uname -m)/${pattern##*/}" ;;
		esac
		case $pattern in
		/*)	pattern="${pattern##/}" ;;
		esac

		case $pattern in
		*/*/*)
			;;
		*)
			kdist__cd_kernel_topdir &&
			kdist__setup_kernel_version ||
			return

			case $pattern in
			*/*)	pattern="$KERNEL_VERSION_BASE/$pattern" ;;
			*)	pattern="$KERNEL_VERSION_BASE/$(uname -m)/$pattern" ;;
			esac
		esac
		config__ls_files "${opts[@]}" "$pattern"
	done
}

#
# The default pattern is based on a passed configuration file and the
# version of the current kernel.
#
config__default_pattern () {
	local name arch

	name=$(config__read_flavour $1) &&
	test -n "$name" ||
	die "Missing CONFIG_NAME, don't know where to propagate changes."

	arch=$(config__read_architecture $1) &&
	test -n "$arch" ||
	die "Unable to determine the architecture of the current config."

	echo $arch/$name
}

#
# Return a tag description given a configuration version.
#
declare -A kernel_tag_map

__to_kern_tag () {
	local ktag
	#
	# First try with current HEAD: if the closest revision is the
	# same as the config one then just use HEAD
	#
	ktag=$(git describe HEAD) &&
	case $ktag in
	$1*)	echo $ktag; return
	esac

	# Otherwise find the most recent distribution tag
	ktag=$(kdist release list -n1 $1\*)
	if test "$ktag"; then
		echo $ktag
		return
	fi

	# Or try to pick the latest matching kernel tag. Note that
	# "x.y.z-rc" will be prefered over "x.y.z"
	ktag=$(git tag -l $1\* | sort -V | tail -1)
	if test "$ktag"; then
		echo $ktag
		return
	fi

	# Just ask to the user...
	warn -n "Enter kernel revision to use for checking this config: "
	while read ktag
	do
		git rev-parse -q --verify $ktag >/dev/null && {
			# Always use a tag description.
			ktag=$(git describe $ktag) &&
			break
		}
		warn -n "Invalid revision, try again: "
	done
	echo $ktag
}

config__map_to_kernel () {
	local vers=v${1#v}

	if ! test ${kernel_tag_map[$vers]}; then
		kernel_tag_map[$vers]=$(__to_kern_tag $vers)
	fi &&
	echo ${kernel_tag_map[$vers]}
}

__config_stash_id=

config__save_repository () {
	kdist__cd_repository configs
	if ! git__check_clean_work_tree 2>/dev/null; then
		__config_stash_id=$(git stash create) ||
		die "git-stash failed"
	fi
	cd - >/dev/null
}

config__restore_repository () {
	kdist__cd_repository configs
	git reset -q --hard HEAD &&
	if test $__config_stash_id; then
		if ! git stash apply -q --index $__config_stash_id; then
			warn "Error when restoring back the previous state !"
			warn "Your previous changes are still stashed."
			warn "Please restore then manually with git-stash."
		fi
	fi
	cd - >/dev/null
}

#
# start the config sub command
#
script=$libexecdir/kdist-$kdist_command--$kdist_subcommand
if ! test -f "$script"; then
	usage
fi
source "$script" "$@"
