#! /bin/bash

USAGE="create [--help] [-f] [<component>]"

force=no

while
	case $1 in
	-f|--force)	force=yes ;;
	-*)		usage ;;
	*)		break
	esac
do
	shift
done

case $# in
0)	component= ;;
1)	component=$1 ;;
*)	usage
esac

declare -A component_tags

cleanup_on_error () {
	for c in ${!component_tags[*]}; do
		case $c in
		kernel)	cd $kernel_topdir ;;
		*)	kdist__cd_repository $c
		esac

		case $c in
		kernel)	git reset -q --hard HEAD~1 ;;
		esac
		git tag -d ${component_tags[$c]}
	done
}
trap cleanup_on_error 0

create__kernel_tag () {
	local n=${ktag##*-}

	git__check_clean_work_tree ||
		die "You must have a clean kernel working tree."

	# We know that the kernel repo is clean so the scmversion
	# indicates an exact match only.
	test $force = no &&
	git describe --exact-match --match=${ktag%-*}-\* &>/dev/null && {
		warn "You're about to create an empty release."
		die  "Use '-f' if you really want to do that."
	}

	# Fatal for the kernel.
	echo -n "Tagging 'kernel' with: $ktag [Y/n]? "
	read yesno
	case $yesno in
	y|yes)	;;
	*)	die "Aborted."
	esac

	# Again, 'n' can be different from 'KERNEL_VERSION_PACKAGE + 1'
	if test $KERNEL_VERSION_PACKAGE; then
		sed -i "/EXTRAVERSION =/s/-$KERNEL_VERSION_PACKAGE/-$n/" Makefile
	else
		sed -i "s/EXTRAVERSION =.*/&-$n/" Makefile
	fi ||
	die "failed to update the top Makefile"

	#
	# Finally ask git to immortalizes the event
	#
	if ! git commit -qas -m "Mandriva Release $ktag"; then
		git checkout -- Makefile
		die "git failed to commit the release."
	fi
	if ! git__tag $ktag; then
		git reset -q --hard HEAD~1
		die "git failed to create the tag."
	fi
	component_tags[kernel]=$ktag
}

create__tag () {
	local component=$1
	local tag

	kdist__cd_repository $component
	echo "*** Entering '$component' repository ***"
	git__check_clean_work_tree

	echo -n "branch  : "
	branch=$(git symbolic-ref -q HEAD)
	case $branch in
	"")	echo "detached !" ;;
	*)	echo "$branch" ;;
	esac
	git --no-pager log -1 --format="subject : %s"
	git --no-pager log -1 --format="commit  : %H%n"

	tag=$(kdist tag list -n1 $ktag.\*)
	case $tag in
	"")
		tag=$ktag.1;;
	*)
		# We want to reuse the last tag if the HEAD is exactly
		# pointing at it.
		git describe --exact-match --match=$tag &>/dev/null && {
			echo "Reusing tag '$tag' for '$component'."
			return
		}
		tag=$ktag.$((${tag##*.} + 1))
	esac

	echo -n "Tagging '$component' with: $tag [Y/n]? "
	read yesno
	case $yesno in
	y|yes)	;;
	*)	echo "skipped."; return ;;
	esac

	# Specific sanity checks.
	case $component in
	configs)
		test -d $(kdist__config_version $ktag)||
		die "Missing configs for kernel '$ktag'."
	esac

	git__tag $tag || die "Aborted."
	component_tags[$component]=$tag

	cd - >/dev/null
}

kdist__cd_kernel_topdir &&
kdist__setup_kernel_version ||
exit

kernel_topdir=$(pwd)

#
# Pick up the kernel revision from the main Makefile then list the
# tags using it as pattern and take the latest rev from the list.
#
base=$(kdist__make_tag)
last=$(kdist tag list -n1 $base-\*)
case "$last" in
"")	n=1;;
*)	n=$((${last##*-} + 1))
esac
ktag=$(kdist__make_tag $n)

case $component in
"")
	create__kernel_tag
	kdist__cd_repository
	for c in $(git submodule foreach -q 'echo $name'); do
		echo
		create__tag $c
	done ;;
kernel)
	create__kernel_tag ;;
*)
	# Always create a new tag/release for the kernel first.
	test $n -eq 1 && die "You must tag the kernel first."
	ktag=$last
	create__tag $component
esac

trap - 0